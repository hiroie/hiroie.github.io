
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>demo</title>

  <!-- three.jsを読み込む(ローカル) -->
  <!-- <script src="./three.js"></script> -->
  <!-- three.jsを読み込む(CDN) -->
  <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=lUBCUt7Kr-v5AxD-QmV9Pmq7fMYZEO67mh-mkqXtU7OtOALVz-gYLROZGfPcO4sF-JEKwnOIM2oQ7IDi6XpQTw" charset="UTF-8"></script><link rel="stylesheet" crossorigin="anonymous" href="https://gc.kis.v2.scr.kaspersky-labs.com/E3E8934C-235A-4B0E-825A-35A08381A191/abn/main.css?attr=aHR0cHM6Ly9lbGVtYTAuZ2l0aHViLmlvL0NHOC9zYW1wbGVfMi5odG1s"/><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
  <script src="OrbitControls.js"></script>
</head>
 <script>
  var init = function() {

    var width = 800,
        height = 600;
  
    var degree = 0, // 角度
    　　radius = 5; // 半径
   
	  // レンダラーを作成
    var renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#myCanvas')
        });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
  
    // シーンを作成
    var scene = new THREE.Scene();
  
    // カメラを作成
    var camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    camera.position.set(0, 17, 15);
    camera.lookAt(0, 0, 0);

    // カメラコントローラーを作成
    const controls = new THREE.OrbitControls(camera,document.body);

    //球
    var textureLoader = new THREE.TextureLoader(); 
    var texture = textureLoader.load("uma.png");
    const material = new THREE.SpriteMaterial({ map: texture,});
    const sprite1 = new THREE.Sprite(material);
    sprite1.position.x = -5;
    sprite1.position.y = 0;
    sprite1.position.z = 0;
    sprite1.scale.set(100,100,100);
    scene.add(sprite1)
	  
　　//正方形
    var boxgeometry = new THREE.BoxGeometry(1,1,1);
    var boxmaterial = new THREE. MeshPhongMaterial({ color: 0x0000ff});
    var box = new THREE.Mesh(boxgeometry,boxmaterial);
    box.castShadow = true;
    box.position.set( 5,0,0);
    scene.add(box);
    
    //長方形  
    var planegeometry = new THREE.PlaneGeometry( 1, 1.5, 3 );
    var planematerial = new THREE.MeshPhongMaterial( {color: 0x00ff00, side: THREE.DoubleSide} );
    var plane = new THREE.Mesh( planegeometry, planematerial );
    plane.castShadow = true;
    plane.position.set(0, 0, 5);
    scene.add( plane );

　　//角錐
    var coneGeometry = new THREE.ConeGeometry( 0.5, 1, 5 ); 
	//半径、高さ、底面の分割数
    var coneMaterial = new THREE. MeshPhongMaterial( {color: 0x0000ff} );
    var cone = new THREE.Mesh( coneGeometry, coneMaterial );
    cone.castShadow = true;
    cone.position.set( 0, 0, -5 );
    scene.add( cone );

　　//角柱もどき
    var cylinderGeometry = new THREE.CylinderGeometry( 0.3, 0.5, 1, 8 );
	//上の底面の半径、下の底面の半径、高さ、何角柱か
    var cylinderMaterial = new THREE.MeshPhongMaterial( {color: 0xffff00} );
    var cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
    cylinder.castShadow = true;
    cylinder.position.set( 0.7, 0, -3.5 );
    scene.add( cylinder );

　　//トーラス
    var torusGeometry = new THREE.TorusGeometry( 0.5, 0.2, 6, 12 ); 
	//半径、ドーナッツの太さ、ドーナッツのチューブ方向の分割数、水平方向の分割数
    var torusMaterial = new THREE. MeshPhongMaterial( { color: 0xffff00 } );
    var torus = new THREE.Mesh( torusGeometry, torusMaterial );
    torus.castShadow = true;  
    torus.position.set( 3.5, 0, 3.5);
    scene.add( torus );

	//なんかクネクネしてるやつ
    var torusKnotGeometry = new THREE.TorusKnotGeometry( 0.5, 0.1, 20, 6, 3, 2 ); 
	//全体的な大きさ、チューブの太さ、クネクネの進む方向に対して何分割するか、
	//チューブ方向に対して何分割するか、残りの二つの数字を変えるとクネクネの形が変わる
    var torusKnotMaterial = new THREE. MeshPhongMaterial( { color: 0xff0000, wireframe:true } );
    var torusKnot = new THREE.Mesh( torusKnotGeometry, torusKnotMaterial );
    torusKnot.castShadow = true;
    torusKnot.position.set( -3.5, 0, 3.5 );
    scene.add( torusKnot );

　　//正十二面体
    var dodecaGeometry = new THREE.DodecahedronGeometry(0.6);
    var dodecaMaterial = new THREE. MeshPhongMaterial( { color: 0xff0000 } );
    var dodeca = new THREE.Mesh( dodecaGeometry, dodecaMaterial );
    dodeca.castShadow = true;
    dodeca.position.set( -3.5, 0, -3.5 );
    scene.add( dodeca );
	  
    //長方形  
    var groundgeometry = new THREE.PlaneGeometry( 15, 15 );
    var groundmaterial = new THREE.MeshPhongMaterial( {color: 0xffffff, side: THREE.FrontSide} );
    var ground = new THREE.Mesh( groundgeometry, groundmaterial );
    ground.receiveShadow = true;
    ground.rotation.set(-Math.PI/2,0,0);
    ground.position.set(0, -2, 0);
    scene.add( ground );

    // 平行光源1
    var pointLight1 = new THREE.PointLight(0xffffff, 2, 50, 1.0);
    pointLight1.position.set(0, 10, 0);
    pointLight1.castShadow = true;
    // シーンに追加
    scene.add(pointLight1);
    // 平行光源2
    var directionalLight2 = new THREE.DirectionalLight(0xffffff);
    directionalLight2.position.set(-1, 1, 1);
    // シーンに追加
    scene.add(directionalLight2);

    // 初回実行
    var update = function() {
        requestAnimationFrame(update);

	degree += 2;
        // 角度をラジアンに変換
        const rad = degree * Math.PI / 180;
	
	//楕円上移動
        sprite1.position.x = 5 * Math.cos(rad+Math.PI);
	sprite1.position.z = Math.sin(rad+Math.PI);
        box.position.x = 5 * Math.cos(rad);
	box.position.z = Math.sin(rad);
        cone.position.x = Math.cos(rad+Math.PI);
	cone.position.z = 5 * Math.sin(rad+Math.PI);
        plane.position.x = Math.cos(rad);
	plane.position.z = 5 * Math.sin(rad);

	//斜め楕円上移動
	cylinder.position.x = 5 * Math.cos(rad + Math.PI/4) * Math.cos(Math.PI/4*7) - Math.sin(rad + Math.PI/4) * Math.sin(Math.PI/4*7);
	cylinder.position.z = Math.sin(rad + Math.PI/4) * Math.cos(Math.PI/4*7) + 5 * Math.cos(rad + Math.PI/4) * Math.sin(Math.PI/4*7);
        torusKnot.position.x = 5 * Math.cos(rad + Math.PI/4) * Math.cos(Math.PI/4*3) - Math.sin(rad + Math.PI/4) * Math.sin(Math.PI/4*3);
	torusKnot.position.z = Math.sin(rad + Math.PI/4) * Math.cos(Math.PI/4*3) + 5 * Math.cos(rad + Math.PI/4) * Math.sin(Math.PI/4*3);
        torus.position.x = 5 * Math.cos(rad + Math.PI/4*3) * Math.cos(Math.PI/4) - Math.sin(rad + Math.PI/4*3) * Math.sin(Math.PI/4);
	torus.position.z = Math.sin(rad + Math.PI/4*3) * Math.cos(Math.PI/4) + 5 * Math.cos(rad + Math.PI/4*3) * Math.sin(Math.PI/4);
        dodeca.position.x = 5 * Math.cos(rad + Math.PI/4*3) * Math.cos(Math.PI/4*5) - Math.sin(rad + Math.PI/4*3) * Math.sin(Math.PI/4*5);
	dodeca.position.z = Math.sin(rad + Math.PI/4*3) * Math.cos(Math.PI/4*5) + 5 * Math.cos(rad + Math.PI/4*3) * Math.sin(Math.PI/4*5);

	renderer.render(scene, camera);
    };
    update();
  }
  window.addEventListener('DOMContentLoaded', init);
</script>
<body>
    <canvas id="myCanvas"></canvas>
</body>
